## **1. What is a Load Balancer in AWS?**

A **Load Balancer** is a middleman that:
- Receives requests from clients
- Distributes them to multiple backend servers
- Ensures high availability, scalability, and fault tolerance

AWS has **three main types**:

- **ALB** (Application Load Balancer) – works at Layer 7 (HTTP/HTTPS)
- **NLB** (Network Load Balancer) – works at Layer 4 (TCP/UDP/TLS)
- **CLB** (Classic Load Balancer) – old, rarely used now
## **2. What Makes NLB Special?**

**Key traits:**

- Works at **Layer 4** (TCP, UDP, TLS)
    
- **Ultra-low latency** — designed for millions of requests/sec
    
- Can handle **static IPs** (one per AZ) or an Elastic IP per AZ
    
- Can **pass the original client IP** to the target (important for logging)
    
- Supports **TLS termination** or pass-through
    

**Why AWS uses it for PrivateLink:**  
PrivateLink needs raw, network-level connections between VPCs. An NLB fits perfectly because it:

- Doesn’t modify packets at the application level
    
- Can handle private IP mappings easily
    
- Supports cross-VPC connections

## **3. NLB Core Components**

You can imagine an NLB as **3 parts working together**:

### **(a) Listeners**

- Think of them as the _front door rules_.
    
- They listen for connections on a specific **protocol + port**.  
    Example: TCP on port 443, UDP on port 53.
    

### **(b) Target Groups**

- A logical group of **targets** (like EC2 instances, IP addresses, or Lambda functions).
    
- Each target group has:
    
    - Protocol (TCP/UDP/TLS)
        
    - Port number
        
    - Health check configuration
        

### **(c) Routing Logic**

- The listener forwards incoming traffic to a target group.
    
- Targets are chosen based on health check status.
    
- NLB does **round-robin** at connection level (TCP/UDP) — not per request like ALB.