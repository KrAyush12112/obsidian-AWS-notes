## ðŸ”¹ Quick Comparison Table

|Feature|**ALB** (Layer 7)|**NLB** (Layer 4)|
|---|---|---|
|Layer|Application (L7)|Transport (L4)|
|Protocols|HTTP, HTTPS, gRPC, WebSockets|TCP, UDP, TLS|
|Routing|Path, Host, Headers, Query String|Port/Protocol only|
|Health Check|URL path + HTTP codes|TCP connect / basic HTTP|
|Performance|ms latency|Âµs latency (very low)|
|Source IP Preservation|Needs X-Forwarded-For header|Preserved natively|
|Use Case|Web apps, microservices, APIs|Gaming, streaming, IoT, databases|
The fundamental difference between an Application Load Balancer (ALB) and a Network Load Balancer (NLB) lies in the **OSI model layer** at which they operate and the **type of traffic** they handle.

- An **ALB** operates at Layer 7 (the application layer) and is ideal for complex web applications that use HTTP/HTTPS protocols.
    
- An **NLB** operates at Layer 4 (the transport layer) and is designed for high-performance, low-latency applications that use TCP, UDP, or TLS protocols.
    

---

### Key Differences in Detail

#### OSI Model Layer & Traffic

- **ALB:** Works at **Layer 7** (Application Layer) and handles **HTTP, HTTPS, and gRPC** traffic. It can read the content of the request, like URL paths and host headers.
    
- **NLB:** Works at **Layer 4** (Transport Layer) and handles **TCP, UDP, and TLS** traffic. It doesn't inspect the content of the request but rather forwards connections based on IP addresses and ports.
    

#### Routing Logic

- **ALB:** Provides **advanced, content-based routing**. You can create rules to route traffic to different target groups based on:
    
    - URL path (`/images` goes to one group, `/api` to another).
        
    - Host header (`app1.example.com` vs. `app2.example.com`).
        
    - HTTP method (GET vs. POST).
        
    - Query strings.
        
- **NLB:** Provides **basic, connection-based routing**. It forwards traffic to a target based on the IP address and port specified in the listener. It uses a flow hash algorithm to route traffic consistently for the life of a connection.
    

#### Performance & Scalability

- **ALB:** It's more CPU-intensive due to its Layer 7 inspection, which adds a bit of latency. It scales automatically but can take a few minutes to adapt to massive, unpredictable traffic spikes.
    
- **NLB:** Extremely performant and provides **ultra-low latency**. Because it doesn't inspect the packet content, it can handle millions of requests per second and is optimized to handle volatile, high-traffic patterns instantly.
    

#### IP Addresses

- **ALB:** Does **not provide static IP addresses**. Its public IP addresses can change, which is fine for most DNS configurations but can be an issue for applications that require a fixed IP for things like firewall allow lists.
    
- **NLB:** Provides a **static IP address** per Availability Zone, or you can assign an Elastic IP. This is a crucial feature for applications that need a fixed, predictable IP address.
    

#### Health Checks

- **ALB:** Conducts **deep health checks** by sending a request (e.g., an HTTP GET) to a specific path and expecting a specific response code. It can tell if a server is failing to respond correctly, not just if it's online.
    
- **NLB:** Conducts **simple health checks** at the TCP or UDP level. It checks if a target is listening on the specified port. It cannot tell if the application itself is working correctly.
    

---

### When to Use Each

- **Choose an ALB** for your typical web applications, microservices, or container-based applications that require intelligent, content-based routing. It's the go-to choice for most modern application architectures.
    
- **Choose an NLB** for high-performance, low-latency applications (like gaming, IoT, or real-time streaming), or when you need a static IP address, or when your application uses protocols other than HTTP/HTTPS.