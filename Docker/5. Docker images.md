### **1. What is a Docker Image?**

**The Simple Definition:** A Docker Image is a **read-only template** used to create containers. It contains everything your application needs to run: the code, runtime (Node.js), libraries, environment variables, and configuration files.

**Key Technical Interview Answer:**

> "A Docker Image is an **immutable** (unchangeable) file comprising multiple **layers**. It is built from a Dockerfile and serves as the base executable environment for a container."
	#üîπ Key Parts of the Definition
	1. **Immutable (unchangeable) file**
	    - Once a Docker image is created, it doesn‚Äôt change.
	    - If you want to modify something (say, add a new library), you don‚Äôt edit the existing image ‚Äî instead, you build a new one.
	    - This immutability ensures consistency: the same image will behave the same way no matter where you run it.
	2.  **Comprising multiple layers**
	- Think of an image like a layered cake üç∞.
	- Each instruction in the Dockerfile (like `FROM`, `RUN`, `COPY`) creates a new layer.
	- Layers are stacked together to form the final image.
	- Benefit: Docker can reuse unchanged layers across different images, saving time and storage.
	1. **Built from a Dockerfile**
	- A **Dockerfile** is just a text file with step-by-step instructions.
	- Example:
	    dockerfile
	```
	    FROM node:18
		COPY . /app
		RUN npm install
		CMD ["node", "server.js"]
	```
	- Each line adds a layer to the image.

---
### **2. The Architecture: Layers (The "Secret Sauce")**

Docker images are not one giant file; 
they are a stack of independent layers. This concept is called the **Union File System (UnionFS)**.

**How Layers Work:** Each instruction in your `Dockerfile` creates a new layer.
- **Layer 1 (Base):** `FROM node:18-alpine` (The OS and Node runtime).
- **Layer 2:** `COPY package.json .` (Your dependency list).
- **Layer 3:** `RUN npm install` (The actual `node_modules` folder).
- **Layer 4:** `COPY . .` (Your actual source code).

**Why do Layers matter? (Efficiency & Caching)**

- **Reusability:** If you have 10 apps that all use `node:18-alpine`, Docker only downloads that layer _once_ and shares it across all 10 apps.
- **Speed:** If you change your code (Layer 4) but not your dependencies (Layer 2), Docker re-uses the old Layer 2 and 3 from the cache. It only rebuilds Layer 4. This makes builds super fast.


### Pull docker image from docker hub
	Docker pull [Option] NAME[:tag]
	
	Command : docker pull ubuntu:latest

## Create own docker image
LATER

# Pushing image 
#### Docker registry
1.  Doker registry - Docker facilates in which you can push image and make them public.
2. You can create private repo too which can be accessible to authorized one.

#### Cloud registry
1. You can also push image to other cloud registry.
2. example AWS - ECR {elastic container registry}
3. Google cloud - GCR
4. Azure - ACR

	Command
		Docker push username/repo:tag
	
