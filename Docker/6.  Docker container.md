#### **1. What is a Container?**

A container is a runnable instance of an image. When you start a container, Docker takes the read-only image and adds a **Read-Write layer** on top of it. This allows the application to run, create temp files, and change states, without altering the original image.

---
#### **2. The Container Lifecycle (The 4 States)**

A container is not always "running." It goes through a lifecycle:

1. **Created:** The container exists but hasn't started (rarely used alone).
    
2. **Running:** The process is active (CPU/RAM are being used).
    
3. **Paused:** The process is frozen (like hitting pause on a video game). It keeps its state in memory but stops using CPU.
    
4. **Stopped/Exited:** The process has been killed. The container still exists on the disk (and can be restarted), but it is not using resources.

---
### **Part 2: Imperative vs. Declarative**

#### **1. Imperative Approach (The "Commander")**

- **Definition:** You tell the system **HOW** to do something, step-by-step.
    
- **Tool:** The Docker CLI (`docker run`, `docker stop`, `docker network create`).
    
- **Analogy:** A cooking recipe: "Crack egg. Beat egg. Heat pan. Pour egg."
    
- **When to use it:**
    
    - Quick testing ("Does this image work?").
    - Debugging.
    - Learning.
        
- **The Problem:** It's hard to reproduce. If you type a long command with 10 flags and forget one next time, your app breaks.
    
**Example (Imperative Command):**

Bash

```
docker run -d --name nestibly -p 3000:3000 -v data:/app/data my-node-app
```

#### **2. Declarative Approach (The "Architect")**

- **Definition:** You tell the system **WHAT** the final result should look like. You don't care about the steps; the tool figures it out.
    
- **Tool:** `docker-compose.yml` (or Kubernetes manifests).
    
- **Analogy:** A Menu Order: "I want a Burger." (You don't tell the chef how to slice the onions).
    
- **When to use it:**
    
    - **Production.**
    - Team collaboration (you can share the file).
    - Multi-container setups (Frontend + Backend + Database).
        
- **The Benefit:** **Infrastructure as Code (IaC).** You can save your configuration in a file, commit it to GitHub, and anyone can spin up your exact environment with one command.
    
**Example (Declarative File - `docker-compose.yml`):**

YAML

```
version: '3.8'
services:
  nestibly:
    image: my-node-app
    ports:
      - "3000:3000"
    volumes:
      - data:/app/data
```

_To run this, you just type: `docker compose up`._

---

### **3. Comparison Table (For Interview Prep)**

|**Feature**|**Imperative**|**Declarative**|
|---|---|---|
|**Focus**|Process (The Steps)|End State (The Result)|
|**Primary Tool**|Docker CLI commands|`docker-compose.yml`|
|**Reproducibility**|Low (easy to forget flags)|High (saved in a file)|
|**Maintenance**|Hard (must document commands)|Easy (read the file)|
|**Best For**|Ad-hoc tasks, Debugging|Production, Complex Apps|
