The **Imperative Approach** means you are giving Docker specific, step-by-step orders using the Command Line Interface (CLI). You act as the "Commander," typing one command after another to achieve your goal.
### **1. The "Master" Command: `docker run`**
The most important imperative command is `docker run`. It does three things in one go:
1. **Pulls** the image (if you don't have it).
2. **Creates** a container.    
3. **Starts** the application.
**The Syntax:**
```
docker run [OPTIONS] IMAGE [COMMAND]
```
**Common "Options" (Flags) You Must Know:**
- `-d` (**Detached**): Runs the container in the background. If you don't use this, the container will "hog" your terminal, and closing the window kills the app.
- `-p` (**Publish Port**): Maps a port on your computer to the container.
    - Format: `host_port:container_port` (e.g., `-p 3000:3000`).
- `--name`: Gives your container a custom nickname (so you don't get random names like `sleepy_beaver`).
- `-it` (**Interactive TTY**): Used if you want to go _inside_ the container terminal (often used with `sh` or `bash`).
- `--rm`: Automatically deletes the container when it stops (good for one-time tests)
- `bin/bash`: this is a shell or enviroment(cli) where you can command to container.
	- `Example: docker run -it image:latest /bin/bash`
### **2. The Imperative Lifecycle (Step-by-Step)**

Here is the exact sequence of commands you would type to manage your **Nestibly** Node.js app manually.

#### **Step 1: Build the Image**

Before you can run a container, you need the image.

```
docker build -t nestibly-app .
```

_(Translation: "Hey Docker, look in the current folder (`.`), follow the Dockerfile instructions, and save the result as an image named `nestibly-app`.")_

#### **Step 2: Run the Container**

Now, let's start it up.

```
docker run -d --name my-website -p 80:3000 nestibly-app
```

_(Translation: "Run `nestibly-app` in the background (`-d`). Call it `my-website`. Send traffic from my computer's Port 80 to the container's Port 3000.")_

#### **Step 3: Check the Status**

Verify it is actually running.

```
docker ps
```

_(Translation: "List all running processes/containers.")_

#### **Step 4: View the Logs**

Something went wrong? See what the app is printing.

Bash

```
docker logs my-website
```

_(Translation: "Show me the console output for the container named `my-website`.")_

#### **Step 5: Stop the Container**

Done for the day? Turn it off.

Bash

```
docker stop my-website
```

#### **Step 6: Remove the Container**

Clean up the mess. (A stopped container still takes up space until you remove it).

Bash

```
docker rm my-website
```

---

### **3. The "Backdoor" Command: `docker exec`**

Sometimes, your app is running, but acting weird. You want to "teleport" inside the container to check files manually.
**The Command:**

```
docker exec -it my-website sh
```

_(Translation: "Execute a command inside `my-website`. The command is `sh` (shell). Make it interactive (`-it`) so I can type.")_

Once you are inside, you can use standard Linux commands like `ls`, `cd`, or `cat` to inspect your files. Type `exit` to leave.

---

### **4. Summary Checklist for Imperative Mode**

| **Goal**                     | **Command**                                   |
| ---------------------------- | --------------------------------------------- |
| **Build**                    | `docker build -t <name> .`                    |
| **Run (Background)**         | `docker run -d -p <host>:<container> <image>` |
| **List Running**             | `docker ps`                                   |
| **List All (incl. stopped)** | `docker ps -a`                                |
| **Stop**                     | `docker stop <container_id>`                  |
| **Delete Container**         | `docker rm <container_id>`                    |
| **Delete Image**             | `docker rmi <image_id>`                       |


# ðŸš€ Docker + Apache2 Setup 
### 1. `apt update`

ðŸ‘‰ System ke package list ko update karne ke liye. Ye ensure karta hai ki tum latest packages install kar sako.

### 2. `docker run -it --name web -p 80:80 ubuntu /bin/bash`

ðŸ‘‰ Ye command ek Ubuntu container start karta hai:

- `-it` â†’ interactive terminal
    
- `--name web` â†’ container ka naam `web`
    
- `-p 80:80` â†’ host port 80 ko container port 80 se map karta hai
    
- `ubuntu /bin/bash` â†’ Ubuntu image ke andar Bash shell open karta hai
    

**Answer to your question:** Ye sirf Ubuntu shell deta hai, Apache2 manually install/start karna padta hai.

> [!NOTE] Kaise pata kare ke host os me hai yeh container me
> - Prompt à¤®à¥‡à¤‚ `root@<container_id>` à¤¦à¤¿à¤–à¥‡ à¤¤à¥‹ à¤¤à¥à¤® container à¤®à¥‡à¤‚ à¤¹à¥‹à¥¤
> - Prompt à¤®à¥‡à¤‚ `ubuntu@ip-...` à¤¦à¤¿à¤–à¥‡ à¤¤à¥‹ à¤¤à¥à¤® EC2 host à¤ªà¤° à¤¹à¥‹à¥¤
> - `hostname` command à¤¸à¥‡ à¤¤à¥à¤°à¤‚à¤¤ clear à¤¹à¥‹ à¤œà¤¾à¤à¤—à¤¾à¥¤
> - `output`: 93d691d382c5 {container id}

### 3. `apt install apache2`

ðŸ‘‰ Apache2 web server install karne ke liye. Ye tumhare container/Ubuntu host ke andar web server setup karta hai.
### 4. `service apache2 start`

ðŸ‘‰ Apache2 ko start karne ke liye. âš ï¸ Tumne initially `service start apache2` likha tha jo galat syntax tha. Correct hai:
```
service apache2 start
```

**Answer to your question:** Docker containers mein `service`/`systemctl` normally kaam nahi karta kyunki init system nahi hota. Isliye `apache2ctl -D FOREGROUND` use karna best hai.

### 5. `cd /var/www/html`

ðŸ‘‰ Ye Apache2 ka default web root hai. Yahan tumhari `index.html` file hoti hai jo browser me serve hoti hai.
File ka content dekhne ke liye `cat index.html` use karo.



> [!NOTE]
> ## â“ Q1: "Maine image ubuntu dala hai aur jab `docker run` command chalata hoon iska matlab hai mai ubuntu ka container bana raha hoon aur run kar raha hoon?"
> 
> ðŸ‘‰ **Answer:** Haan, exactly.
> 
> - **Image** = ek template hai (Ubuntu ka snapshot jisme basic filesystem + binaries hote hain).
>     
> - Jab tum `docker run ubuntu` chalate ho, Docker us image se ek **container** banata hai.
>     
> - Container = ek isolated environment jo host ke kernel use karta hai, but apna filesystem aur processes rakhta hai.
>     
> 
> So yes, tum Ubuntu image se ek **Ubuntu container** bana rahe ho aur usko run kar rahe ho.
> 

> [!NOTE]
> ## â“ Q2: "Yeh image Ubuntu OS ka lightweight version hai?"
> 
> ðŸ‘‰ **Answer:** Haan, Docker Hub par jo **official Ubuntu image** hai wo ek **minimal / lightweight version** hota hai:
> 
> - Isme **sirf base OS libraries aur essential tools** hote hain (jaise `bash`, `apt`, etc.).
>     
> - GUI, extra packages, aur heavy tools nahi hote.
>     
> - Matlab ye **full Ubuntu desktop** nahi hai, balki ek strippedâ€‘down version hai jo container ke liye optimized hai.
>     
> 
> Isliye tumhe agar Apache2, Python, Node.js, ya koi aur software chahiye, to tumhe manually `apt install` karke add karna padta hai.

> [!NOTE]
> ## ðŸ”¹ Q1: "Docker run command me port decide kyu karna padta hai?"
> 
> ðŸ‘‰ **Reason:**
> 
> - Jab tum `docker run -p 80:80 ...` likhte ho, iska matlab hai:
>     
>     - **Host port 80** â†’ **Container port 80** se map ho raha hai.
>         
> - Container ek **isolated environment** hai. Uska apna internal IP hota hai (jaise `172.17.0.2`).
>     
> - Agar tum port mapping nahi karoge, to container ke andar chal raha Apache/Nginx **sirf container ke andar hi accessible hoga**, host ya public network se nahi.
>     
> - Port mapping ek **bridge** banata hai jisse tum host machine (aur EC2 ke public IP) se container ke andar ke service ko access kar sako.
>     
> 
> âš¡ Example:
> 
> bash
> 
> ```
> docker run -dit -p 8080:80 nginx
> ```
> 
> - Host ke port `8080` â†’ Container ke port `80`.
>     
> - Browser me `http://localhost:8080` â†’ Container ke andar Nginx ka `index.html`.
>     
> 
> ðŸ‘‰ **Summary:** Port mapping isliye zaroori hai taaki container ke andar chal raha web server bahar se accessible ho.

> [!NOTE]
> ## ðŸ”¹ Q2: "/bin/bash ke jagah sh use karu to alag hoga?"
> 
> ðŸ‘‰ **Difference:**
> 
> - `/bin/bash` â†’ Bash shell (feature-rich, advanced scripting, colors, history, tab completion).
>     
> - `sh` â†’ POSIX shell (basic, lightweight, minimal features).
>     
> - Ubuntu image me Bash hota hai, lekin Nginx/Alpine jaise lightweight images me Bash nahi hota, sirf `sh` hota hai.
>     
> 
> âš¡ Example:
> 
> bash
> 
> ```
> docker run -it ubuntu /bin/bash
> ```
> 
> â†’ Tum Bash shell ke andar jaoge.
> 
> bash
> 
> ```
> docker run -it ubuntu sh
> ```
> 
> â†’ Tum simple shell ke andar jaoge (limited features).
> 
> ðŸ‘‰ **Commands mostly same hote hain** (ls, cd, cat, etc.), lekin Bash me tumhe extra features milte hain jo sh me nahi milte (jaise arrays, advanced scripting, tab completion).